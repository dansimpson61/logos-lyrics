# lyrics_service.rb

require 'http'
require 'json'
require 'uri'
require 'nokogiri'

# Base lyrics service class
class LyricsService
  def search(term)
    raise NotImplementedError, 'This method should be implemented by subclasses'
  end

  def fetch_lyrics(track_id)
    raise NotImplementedError, 'This method should be implemented by subclasses'
  end
end

# Musixmatch service subclass
class MusixmatchService < LyricsService
  API_KEY = ENV['MUSIXMATCH_API_KEY']
  BASE_URL = 'https://api.musixmatch.com/ws/1.1/'

  def search(term)
    return [] unless API_KEY
    url = "#{BASE_URL}track.search?q_track_artist=#{URI.encode_www_form_component(term)}&page_size=10&page=1&s_track_rating=desc&apikey=#{API_KEY}"
    response = HTTP.get(url)
    return [] unless response.status.success?

    tracks = JSON.parse(response.body.to_s)['message']['body']['track_list']
    tracks.select { |track| track['track']['has_lyrics'] }.map do |track|
      {
        id: track['track']['track_id'],
        title: track['track']['track_name'],
        artist: track['track']['artist_name'],
        service: 'musixmatch'
      }
    end
  rescue => e
    puts "Error in MusixmatchService#search: #{e.message}"
    []
  end

  def fetch_lyrics(track_id)
    return "" unless API_KEY
    url = "#{BASE_URL}track.lyrics.get?track_id=#{track_id}&apikey=#{API_KEY}"
    response = HTTP.get(url)
    return "" unless response.status.success?

    JSON.parse(response.body.to_s)['message']['body']['lyrics']['lyrics_body']
  rescue => e
    puts "Error in MusixmatchService#fetch_lyrics: #{e.message}"
    ""
  end
end

# Lyrics.ovh service subclass
class LyricsOvhService < LyricsService
  BASE_URL = 'https://api.lyrics.ovh/v1/'

  def search(term)
    url = "#{BASE_URL}suggest/#{URI.encode_www_form_component(term)}"
    response = HTTP.get(url)
    return [] unless response.status.success?

    JSON.parse(response.body.to_s)['data'].map do |track|
      {
        id: "#{track['artist']['name']}/#{track['title']}",
        title: track['title'],
        artist: track['artist']['name'],
        service: 'lyricsovh'
      }
    end
  rescue => e
    puts "Error in LyricsOvhService#search: #{e.message}"
    []
  end

  def fetch_lyrics(track_id)
    # track_id for lyrics.ovh is "artist/title"
    artist, title = track_id.split('/', 2)
    return "" unless artist && title

    url = "#{BASE_URL}#{URI.encode_www_form_component(artist)}/#{URI.encode_www_form_component(title)}"
    response = HTTP.get(url)
    return "" unless response.status.success?

    JSON.parse(response.body.to_s)['lyrics']
  rescue => e
    puts "Error in LyricsOvhService#fetch_lyrics: #{e.message}"
    ""
  end
end

# AZLyrics service subclass
class AZLyricsService < LyricsService
  BASE_URL = 'https://search.azlyrics.com/search.php'

  def search(term)
    url = "#{BASE_URL}?q=#{URI.encode_www_form_component(term)}"
    response = HTTP.get(url)
    return [] unless response.status.success?

    # Return the raw HTML as a dummy result for debugging
    [{
      id: response.body.to_s,
      title: "DEBUG: Raw HTML",
      artist: "AZLyrics",
      service: "azlyrics_debug"
    }]
  rescue => e
    [{
      id: "Error: #{e.message}",
      title: "DEBUG: Error",
      artist: "AZLyrics",
      service: "azlyrics_debug"
    }]
  end

  def fetch_lyrics(song_url)
    response = HTTP.get(song_url)
    return "" unless response.status.success?

    doc = Nokogiri::HTML(response.body.to_s)

    # The lyrics are in a div that is not styled, after the "Usage of azlyrics.com content" comment
    lyrics_comment_xpath = "//comment()[contains(., 'Usage of azlyrics.com content')]"
    comment_node = doc.xpath(lyrics_comment_xpath).first

    if comment_node
      lyrics_div = comment_node.parent.xpath('following-sibling::div[1]').first
      if lyrics_div
        return lyrics_div.inner_html.gsub('<br>', "\n").strip
      end
    end

    # Fallback if the comment is not found
    "Lyrics not found on page."
  rescue => e
    puts "Error in AZLyricsService#fetch_lyrics: #{e.message}"
    ""
  end
end
